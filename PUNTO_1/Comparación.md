# Análisis Comparativo entre Programación Imperativa y Declarativa

En el desarrollo del ejercicio se implementaron dos enfoques de programación diferentes para resolver el mismo problema: ordenar una lista de estudiantes con sus calificaciones de forma descendente y, en caso de empate, en orden alfabético. Aunque ambos métodos alcanzan el mismo resultado, la forma de lograrlo es distinta y esto se refleja en la claridad, la abstracción, el manejo de datos, el mantenimiento y la eficiencia del código.

En la solución imperativa, el código describe de manera explícita cada paso que debe ejecutarse para alcanzar el objetivo. Se utiliza un algoritmo de burbuja que recorre la lista, compara elementos y los intercambia cuando es necesario. Este enfoque brinda un control total sobre el proceso, pero genera un código más extenso y detallado, lo que puede dificultar su lectura y comprensión, especialmente para quienes no estén familiarizados con la lógica de ordenamiento. Además, como se manipula el contenido de la lista durante las iteraciones, se trabaja directamente con la mutabilidad de las estructuras de datos y se mantiene un estado que va cambiando en cada paso del algoritmo.

Por otro lado, la solución declarativa se centra en expresar qué se quiere lograr, delegando al lenguaje la tarea de decidir cómo hacerlo. Gracias a la función integrada `sorted()` de Python, el código se reduce a una sola línea en la que se especifica el criterio de ordenamiento mediante una expresión `lambda`. Esto hace que la intención del programa sea inmediata y clara, sin necesidad de seguir paso a paso el funcionamiento interno del algoritmo. Además, al generar una nueva lista ordenada, se favorece un estilo más cercano a la inmutabilidad y se evita modificar el estado de los datos originales.

En términos de mantenibilidad, el enfoque declarativo resulta mucho más flexible. Si en el futuro se desea cambiar el criterio de ordenamiento, basta con ajustar la función clave (`key`) de `sorted()`, mientras que en la solución imperativa habría que modificar directamente la lógica interna del algoritmo, lo que implica más trabajo y mayor probabilidad de introducir errores.

Respecto a la eficiencia, la diferencia es significativa. El algoritmo de burbuja implementado en la solución imperativa tiene una complejidad temporal de O(n²), lo que lo hace poco óptimo para listas grandes. En cambio, la función `sorted()` utiliza internamente timsort, un algoritmo híbrido con complejidad promedio de O(n log n), lo que ofrece un rendimiento mucho mejor sin necesidad de que el programador intervenga en los detalles técnicos.

En conclusión, aunque ambos enfoques cumplen con el objetivo propuesto, sus características los hacen más adecuados para contextos distintos. La programación imperativa es útil para comprender en detalle cómo funciona un algoritmo y tener control absoluto sobre cada paso, pero su mantenimiento y rendimiento pueden verse limitados. La programación declarativa, en cambio, permite escribir código más claro, compacto y eficiente, lo que la convierte en una opción más conveniente en entornos reales donde la legibilidad, la mantenibilidad y la optimización son prioritarias.

